<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>네온 테트리스</title>
<style>
:root{
  --neon-cyan:#00fff0;
  --neon-pink:#ff00e6;
  --neon-yellow:#ffd60a;
  --neon-green:#00ff6a;
  --neon-red:#ff3b30;
  --neon-blue:#1e90ff;
  --neon-purple:#a78bfa;
  --bg:#0a0a0f;
}

/* ===== 전체 화면 배경 ===== */
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  background: radial-gradient(circle at 50% 50%, #11131a 0%, #1a1a2f 60%, #000020 100%);
  overflow: hidden;
  color: #fff;
}

/* 캔버스 배경 (네온 효과용) */
canvas#neonBg {
  position: fixed;
  top: 0; left: 0;
  width: 100vw;
  height: 100vh;
  z-index: -1;
  display: block;
}

/* ===== 게임 레이아웃 ===== */
.wrap {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 16px;
  height: 100%;
  padding-top: 20px;
}

/* ==== Board ==== */
#board {
  width: 240px;
  height: 480px;
  background: #0f1119;
  border: 3px solid var(--neon-cyan);
  border-radius: 14px;
  box-shadow: 0 0 24px rgba(0,255,240,.45), inset 0 0 12px rgba(0,255,240,.15);
  outline: none;
}

/* ==== Side Panel ==== */
.panel {
  width: 180px;
  background: #11121b;
  border: 2px solid var(--neon-pink);
  box-shadow: 0 0 24px rgba(255,0,230,.35), inset 0 0 12px rgba(255,0,230,.08);
  border-radius: 14px;
  padding: 12px;
}
.panel h3 {
  margin: 0 0 6px;
  font-weight: 700;
  color: var(--neon-pink);
  text-shadow: 0 0 12px rgba(255,0,230,.8), 0 0 24px rgba(255,0,230,.5);
}
.stat {
  font-size: 14px;
  margin: 6px 0 12px;
  text-shadow: 0 0 4px rgba(255,255,255,.4);
}
#holdCanvas, #nextCanvas {
  width: 120px;
  height: 120px;
  display: block;
  margin: 6px auto 4px;
  background: #0d0f15;
  border: 1px solid #6b7280;
  border-radius: 10px;
}
.hint {
  font-size: 12px;
  color: #a5b4fc;
  opacity: .9;
  text-align: center;
}
#combo {
  color: var(--neon-cyan);
  text-shadow: 0 0 12px rgba(0,255,240,.8);
}

/* ==== Start Screen ==== */
#startScreen {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  background: radial-gradient(800px 600px at 50% 30%, #141622 0%, #0a0a0f 60%, #000 100%);
  z-index: 10;
}
.start-card {
  text-align: center;
  padding: 28px 32px;
  background: rgba(10,12,20,.6);
  border: 2px solid var(--neon-cyan);
  border-radius: 16px;
  box-shadow: 0 0 32px rgba(0,255,240,.45), inset 0 0 24px rgba(0,255,240,.08);
  backdrop-filter: blur(6px);
}
.title {
  font-size: 44px;
  margin: 0 0 12px;
  color: var(--neon-cyan);
  letter-spacing: .12em;
  text-shadow: 0 0 16px rgba(0,255,240,.9), 0 0 40px rgba(0,255,240,.35);
}
.subtitle {
  margin: 0 0 18px;
  color: #c7d2fe;
  opacity: .9;
}
.btn {
  cursor: pointer;
  border: 2px solid var(--neon-pink);
  color: var(--neon-pink);
  background: transparent;
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 12px;
  transition: transform .08s ease, box-shadow .2s ease, background .2s ease, color .2s ease;
  text-shadow: 0 0 8px rgba(255,0,230,.8);
  box-shadow: 0 0 18px rgba(255,0,230,.35);
}
.btn:hover { background: var(--neon-pink); color: #000; }
.btn:active { transform: translateY(1px) scale(.99); }
.controls {
  margin-top: 14px;
  font-size: 13px;
  color: #e5e7eb;
  opacity: .95;
  line-height: 1.5;
}
.kbd {
  display: inline-block;
  border: 1px solid #94a3b8;
  border-radius: 6px;
  padding: 1px 6px;
  margin: 0 2px;
  background: #0b0d14;
}

/* Pause overlay */
#pauseOverlay, #gameOverScreen {
  position: fixed;
  inset: 0;
  display: grid;
  place-items: center;
  z-index: 20;
  font-family: 'ui-sans-serif';
}
#pauseOverlay .card {
  padding: 20px 28px;
  border-radius: 12px;
  text-align: center;
  background: rgba(5,7,12,0.8);
  border: 2px solid var(--neon-yellow);
  color: var(--neon-yellow);
  box-shadow: 0 0 20px rgba(255,220,40,0.12);
}
</style>
</head>
<body>

<canvas id="neonBg"></canvas>

<div id="startScreen">
  <div class="start-card">
    <div class="title">NEON TETRIS</div>
    <p class="subtitle">Classic 10×20 · Hold · Hard Drop · SRS · Combo</p>
    <button id="startBtn" class="btn">게임 시작</button>
    <div class="controls">
      조작: <span class="kbd">←</span><span class="kbd">→</span> 이동 · <span class="kbd">↑</span> 회전 · 
      <span class="kbd">↓</span> 소프트드롭 · <span class="kbd">Space</span> 하드드롭 · 
      <span class="kbd">Shift</span> 홀드 · <span class="kbd">P</span> 일시정지
    </div>
    <p class="hint">또는 <span class="kbd">Space</span>로 시작</p>
    <p class="hint">하이스코어: <span id="startHigh">0</span></p>
  </div>
</div>

<div id="pauseOverlay" style="display:none; z-index:30">
  <div class="card"><div style="font-size:40px;font-weight:700">PAUSED</div><div style="margin-top:8px;font-size:14px;opacity:.9">P 누르면 재개</div></div>
</div>

<div class="wrap">
  <canvas id="board" width="240" height="480" tabindex="0"></canvas>
  <aside class="panel">
    <h3>HOLD</h3>
    <canvas id="holdCanvas" width="120" height="120"></canvas>
    <div class="hint">Shift = Hold</div>

    <h3>NEXT</h3>
    <canvas id="nextCanvas" width="120" height="120"></canvas>

    <h3>POINTS</h3>
    <div class="stat">점수: <span id="score">0</span></div>

    <h3>COMBO</h3>
    <div class="stat">콤보: <span id="combo">0</span></div>

    <h3>TIME</h3>
    <div class="stat" id="time">시간: 0초</div>

    <h3>HIGH</h3>
    <div class="stat">하이스코어: <span id="highscore">0</span></div>
  </aside>
</div>

<script>
// ===== Neon Background =====
const bgCanvas = document.getElementById('neonBg');
const bg = bgCanvas.getContext('2d');

function resizeBg() {
  bgCanvas.width = window.innerWidth;
  bgCanvas.height = window.innerHeight;
}
resizeBg();
window.addEventListener('resize', resizeBg);

const gridSize = 50;
function drawBgGrid() {
  bg.clearRect(0,0,bgCanvas.width,bgCanvas.height);
  bg.strokeStyle = 'rgba(0,255,255,0.25)';
  bg.shadowColor = 'rgba(0,255,255,0.35)';
  bg.shadowBlur = 12;
  bg.lineWidth = 1;
  for(let x=0;x<bgCanvas.width;x+=gridSize){
    bg.beginPath(); bg.moveTo(x,0); bg.lineTo(x,bgCanvas.height); bg.stroke();
  }
  for(let y=0;y<bgCanvas.height;y+=gridSize){
    bg.beginPath(); bg.moveTo(0,y); bg.lineTo(bgCanvas.width,y); bg.stroke();
  }
}

const starColors = ['#00fff0','#ff00e6','#ffd60a','#1e90ff','#a78bfa'];
const particles = Array.from({length:150}, () => ({
  x: Math.random()*window.innerWidth,
  y: Math.random()*window.innerHeight,
  r: Math.random()*2+1.5,
  vx:(Math.random()-0.5)*0.3,
  vy:(Math.random()-0.5)*0.3,
  color: starColors[Math.floor(Math.random()*starColors.length)],
  alpha: Math.random()*0.4+0.3
}));

function drawParticles() {
  for(const p of particles){
    p.x += p.vx; p.y += p.vy;
    if(p.x<0)p.x=bgCanvas.width; if(p.x>bgCanvas.width)p.x=0;
    if(p.y<0)p.y=bgCanvas.height; if(p.y>bgCanvas.height)p.y=0;
    bg.fillStyle=p.color; bg.globalAlpha=p.alpha;
    bg.shadowColor=p.color; bg.shadowBlur=14;
    bg.beginPath(); bg.arc(p.x,p.y,p.r,0,Math.PI*2); bg.fill();
  }
  bg.globalAlpha=1;
}

(function animateBackground() {
  drawBgGrid();
  drawParticles();
  requestAnimationFrame(animateBackground);
})();
</script>

<!-- ===== 여기부터 기존 Tetris JS ===== -->
<script>
    // ===== Tetris JS =====
const board = document.getElementById('board');
const ctx = board.getContext('2d');
const CELL = 24;
ctx.scale(CELL, CELL);

const holdCanvas = document.getElementById('holdCanvas');
const holdCtx = holdCanvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nextCtx = nextCanvas.getContext('2d');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const timeEl = document.getElementById('time');
const startScreen = document.getElementById('startScreen');
const startBtn = document.getElementById('startBtn');
const pauseOverlay = document.getElementById('pauseOverlay');
const highEl = document.getElementById('highscore');
const startHighEl = document.getElementById('startHigh');

const WIDTH = 10, HEIGHT = 20;
const arena = Array.from({length:HEIGHT},()=>Array(WIDTH).fill(0));

let player = {pos:{x:0,y:0}, matrix:null, next:null};
let score = 0, combo = 0, lastTime = 0, dropCounter = 0, dropInterval = 500, running = false;
let elapsedTime = 0;
let holdMatrix = null, canHold = true;
let softLock = false, softLockTimer = 0;
const clearAnim = {active:false, lines:[], t:0, particles:[], awarded:false};
const colors = [null,'#00fff0','#ff00e6','#ffd60a','#00ff6a','#ff3b30','#1e90ff','#a78bfa'];

let highscore = parseInt(localStorage.getItem('neonTetrisHigh')||'0',10);
highEl.textContent = highscore;
startHighEl.textContent = highscore;

// ===== Pieces =====
function createPiece(t){
  switch(t){
    case 'T': return [[0,0,0],[1,1,1],[0,1,0]];
    case 'O': return [[2,2],[2,2]];
    case 'L': return [[0,3,0],[0,3,0],[0,3,3]];
    case 'J': return [[0,4,0],[0,4,0],[4,4,0]];
    case 'I': return [[0,5,0,0],[0,5,0,0],[0,5,0,0],[0,5,0,0]];
    case 'S': return [[0,6,6],[6,6,0],[0,0,0]];
    case 'Z': return [[7,7,0],[0,7,7],[0,0,0]];
  }
}
let bag = [];
function nextPiece(){
  if(!bag.length){
    bag = 'TJLOSZI'.split('');
    bag.sort(()=>Math.random()-0.5);
  }
  return createPiece(bag.pop());
}

// ===== Utils =====
function collide(arena, player){
  const m = player.matrix, o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0){
        const ay = y+o.y, ax = x+o.x;
        if(ay>=arena.length || ax<0 || ax>=arena[0].length) return true;
        if(ay>=0 && arena[ay][ax]!==0) return true;
      }
    }
  }
  return false;
}
function merge(arena,player){
  player.matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{ if(v!==0) arena[y+player.pos.y][x+player.pos.x]=v; });
  });
}
function getFullLines(){
  const lines=[];
  outer: for(let y=HEIGHT-1;y>=0;y--){
    for(let x=0;x<WIDTH;x++) if(arena[y][x]===0) continue outer;
    lines.push(y);
  }
  return lines;
}

// ===== Spawn / Reset =====
function playerReset(){
  player.matrix = player.next || nextPiece();
  player.next = nextPiece();
  player.pos.y = 0;
  player.pos.x = (WIDTH>>1) - ((player.matrix[0].length)>>1);
  canHold = true; softLock = false; softLockTimer = 0;
  if(collide(arena, player)) gameOver();
  drawNext(); drawHold();
}

// ===== Game Over =====
function gameOver(){ running=false; showGameOverScreen(); }
function showGameOverScreen(){
  const existing = document.getElementById('gameOverScreen');
  if(existing) existing.remove();
  const div = document.createElement('div');
  div.id='gameOverScreen';
  Object.assign(div.style,{
    position:'fixed', inset:0, display:'grid', placeItems:'center',
    background:'rgba(10,10,20,0.95)', color:'#00fff0', zIndex:40, fontFamily:'ui-sans-serif', textAlign:'center'
  });
  div.innerHTML = `
    <h1 style="font-size:48px; margin:0 0 12px; text-shadow:0 0 16px #00fff0">GAME OVER</h1>
    <p style="font-size:20px; margin:0 0 8px">점수: ${score}</p>
    <p style="font-size:16px; margin:0 0 12px">하이스코어: ${highscore}</p>
    <button id="restartBtn" style="
      padding:10px 20px; font-size:18px; border:2px solid #ff00e6;
      background:transparent; color:#ff00e6; border-radius:12px; cursor:pointer;
      text-shadow:0 0 8px #ff00e6; box-shadow:0 0 18px rgba(255,0,230,.35);
    ">다시 시작</button>
  `;
  document.body.appendChild(div);
  document.getElementById('restartBtn').addEventListener('click',()=>{
    div.remove(); arena.forEach(r=>r.fill(0)); score=0; combo=0; elapsedTime=0; updateScore();
    running=true; lastTime = performance.now(); playerReset(); update(lastTime);
  });
  if(score > highscore){ highscore = score; localStorage.setItem('neonTetrisHigh', String(highscore)); highEl.textContent = highscore; startHighEl.textContent = highscore; }
}

// ===== Movement / Drop =====
function playerMove(d){
  if(clearAnim.active || paused) return;
  player.pos.x += d;
  if(collide(arena,player)) player.pos.x -= d;
  else if(softLock) softLockTimer = 0;
}
function rotateMatrix(m){ for(let y=0;y<m.length;y++) for(let x=0;x<y;x++) [m[x][y],m[y][x]]=[m[y][x],m[x][y]]; m.forEach(r=>r.reverse()); }
const kicks={normal:[[0,0],[-1,0],[1,0],[0,-1],[-1,-1],[1,-1]], I:[[0,0],[-2,0],[1,0],[-2,-1],[1,2]]};
function playerRotate(){
  if(clearAnim.active || paused) return;
  const m = player.matrix, ox = player.pos.x, oy = player.pos.y;
  rotateMatrix(m);
  const table = (m.length === 4) ? kicks.I : kicks.normal;
  let rotated = false;
  for(const [kx, ky] of table){
    player.pos.x = ox + kx; player.pos.y = oy + ky;
    if(!collide(arena, player)){ rotated = true; break; }
  }
  if(!rotated){ rotateMatrix(m); rotateMatrix(m); rotateMatrix(m); player.pos.x = ox; player.pos.y = oy; }
  else if(softLock) softLockTimer = 0;
}
function softDrop(){
  if(clearAnim.active || paused) return;
  player.pos.y++;
  if(collide(arena, player)){ player.pos.y--; startSoftLock(); }
  dropCounter = 0;
}
function hardDrop(){
  if(clearAnim.active || paused) return;
  while(!collide(arena,player)) player.pos.y++;
  player.pos.y--; lockPiece();
}
function startSoftLock(){ if(!softLock){ softLock = true; softLockTimer = 0; } }
function cancelSoftLockIfFloating(){ if(!softLock) return; player.pos.y++; const c = collide(arena, player); player.pos.y--; if(!c){ softLock = false; softLockTimer = 0; } }

// ===== Lock / Clear =====
function lockPiece(){
  merge(arena,player);
  const lines = getFullLines();
  if(lines.length) startClearAnimation(lines); else { combo=0; updateScore(); }
  playerReset();
}
function startClearAnimation(lines){ clearAnim.active=true; clearAnim.lines = lines.slice().sort((a,b)=>a-b); clearAnim.t=0; clearAnim.particles=[]; clearAnim.awarded=false; }
function finishClearAnimation(){
  const n = clearAnim.lines.length;
  clearAnim.lines.sort((a,b)=>a-b).forEach((y,i)=> arena.splice(y-i,1));
  for(let i=0;i<n;i++) arena.unshift(Array(WIDTH).fill(0));
  const points=[0,100,300,500,800];
  score += points[n] + (combo+1)*50; combo = (n>0)? combo+1:0; updateScore();
  clearAnim.active=false; clearAnim.lines.length=0; clearAnim.particles.length=0; clearAnim.t=0; clearAnim.awarded=true;
}

// ===== Hold / Next =====
function hold(){
  if(clearAnim.active || !canHold || paused) return;
  if(!holdMatrix){ holdMatrix=player.matrix; playerReset(); }
  else{ const tmp=player.matrix; player.matrix=holdMatrix; holdMatrix=tmp; player.pos.y=0; player.pos.x=(WIDTH>>1)-((player.matrix[0].length)>>1); if(collide(arena,player)){ player.matrix=tmp; player.pos.x=(WIDTH>>1)-((player.matrix[0].length)>>1); } }
  canHold=false; drawHold();
}
function drawHold(){
  const s=12;
  holdCtx.setTransform(1,0,0,1,0,0);
  holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height);
  holdCtx.fillStyle='#0d0f15'; holdCtx.fillRect(0,0,holdCanvas.width,holdCanvas.height);
  holdCtx.strokeStyle='#6b7280'; holdCtx.strokeRect(0.5,0.5,holdCanvas.width-1,holdCanvas.height-1);
  if(!holdMatrix) return;
  holdCtx.save(); holdCtx.scale(s,s);
  const vw=holdCanvas.width/s, vh=holdCanvas.height/s;
  const offX=(vw-holdMatrix[0].length)/2, offY=(vh-holdMatrix.length)/2;
  drawMatrix(holdCtx,holdMatrix,{x:offX,y:offY});
  holdCtx.restore();
}
function drawNext(){
  const s=12;
  nextCtx.setTransform(1,0,0,1,0,0);
  nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  nextCtx.fillStyle='#0d0f15'; nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
  nextCtx.strokeStyle='#6b7280'; nextCtx.strokeRect(0.5,0.5,nextCanvas.width-1,nextCanvas.height-1);
  if(!player.next) return;
  nextCtx.save(); nextCtx.scale(s,s);
  const vw=nextCanvas.width/s, vh=nextCanvas.height/s;
  const offX=(vw-player.next[0].length)/2, offY=(vh-player.next.length)/2;
  drawMatrix(nextCtx,player.next,{x:offX,y:offY});
  nextCtx.restore();
}

// ===== Drawing =====
function drawMatrix(targetCtx,matrix,offset, opts = {}){
  matrix.forEach((row,y)=>{
    row.forEach((v,x)=>{
      if(v!==0){
        if(opts.alpha !== undefined) targetCtx.globalAlpha = opts.alpha;
        targetCtx.fillStyle=colors[v];
        targetCtx.fillRect(x+offset.x,y+offset.y,1,1);
        targetCtx.strokeStyle='rgba(0,0,0,.3)';
        targetCtx.lineWidth=0.05;
        targetCtx.strokeRect(x+offset.x,y+offset.y,1,1);
        if(opts.alpha !== undefined) targetCtx.globalAlpha = 1;
      }
    });
  });
}
function drawGrid(){
  ctx.strokeStyle='rgba(0,255,255,.25)';
  ctx.lineWidth=0.03;
  for(let x=0;x<=WIDTH;x++){ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke();}
  for(let y=0;y<=HEIGHT;y++){ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke();}
}
function drawBoard(){
  ctx.setTransform(CELL,0,0,CELL,0,0);
  ctx.fillStyle='#0d0f15';
  ctx.fillRect(0,0,board.width,board.height);

  // ghost
  drawGhost();

  drawMatrix(ctx,arena,{x:0,y:0});
  drawMatrix(ctx,player.matrix,player.pos);
  drawGrid();
}
function drawGhost(){
  const ghost = JSON.parse(JSON.stringify(player.matrix));
  const pos = {x:player.pos.x, y:player.pos.y};
  while(true){
    pos.y++;
    let collision = false;
    for(let y=0;y<ghost.length;y++){
      for(let x=0;x<ghost[y].length;x++){
        if(ghost[y][x]!==0){
          const ay = y+pos.y, ax = x+pos.x;
          if(ay>=arena.length || ax<0 || ax>=arena[0].length){ collision = true; break; }
          if(ay>=0 && arena[ay][ax]!==0){ collision = true; break; }
        }
      }
      if(collision) break;
    }
    if(collision){ pos.y--; break; }
  }
  drawMatrix(ctx,ghost,pos,{alpha:0.25});
}

function drawClearAnimation(dt){
  if(!clearAnim.active) return;
  clearAnim.t+=dt;
  const flashPeriod=70;
  const flashes=Math.floor(clearAnim.t/flashPeriod);
  const on=flashes%2;
  if(flashes<=5){
    clearAnim.lines.forEach(y=>{
      if(on){
        ctx.fillStyle='rgba(0,255,255,0.5)';
        ctx.fillRect(0,y,WIDTH,1);
      }
    });
  }else finishClearAnimation();
}

// ===== Score + Time =====
function updateScore(){
  scoreEl.textContent=score;
  comboEl.textContent=combo;
  timeEl.textContent = Math.floor(elapsedTime/1000) + 's';
}

// ===== Game Loop =====
function update(time = performance.now()){
  if(!running) return;
  const dt = time - lastTime;
  lastTime = time;

  if(!paused){
    elapsedTime += dt;
    dropCounter += dt;
    if(dropCounter > dropInterval){
      player.pos.y++;
      if(collide(arena,player)){ player.pos.y--; startSoftLock(); }
      dropCounter=0;
    }

    if(softLock){
      softLockTimer += dt;
      if(softLockTimer > 1500){ lockPiece(); softLock=false; softLockTimer=0; }
    }
  }

  drawBoard();
  drawClearAnimation(dt);
  updateScore();

  requestAnimationFrame(update);
}

// ===== Input =====
document.addEventListener('keydown', e=>{
  if(!running) return;
  if(e.key==='ArrowLeft') playerMove(-1);
  else if(e.key==='ArrowRight') playerMove(1);
  else if(e.key==='ArrowDown') softDrop();
  else if(e.key==='ArrowUp') playerRotate();
  else if(e.key===' ') hardDrop();
  else if(e.key==='Shift') hold();
  else if(e.key==='Escape') togglePause();
});

let paused=false;
function togglePause(){
  paused=!paused;
  pauseOverlay.style.display = paused ? 'grid' : 'none';
}

// ===== Start =====
startBtn.addEventListener('click',()=>{
  startScreen.style.display='none';
  running=true; lastTime=performance.now();
  playerReset(); update(lastTime);
});
</script>

</body>
</html>
